name: CI/CD Pipeline

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Ambiente de despliegue (production, staging, etc.)"
        required: false
        default: "production"
        type: choice
        options:
          - production
          - staging
          - development
      run_infra:
        description: "Ejecutar provisioning de infra con Terraform (true/false)"
        required: false
        default: "true"
        type: choice
        options:
          - "true"
          - "false"
      recreate_db:
        description: "Recrear base de datos (true/false)"
        required: false
        default: "false"
        type: choice
        options:
          - "true"
          - "false"
      deploy_api:
        description: "Desplegar API (true/false)"
        required: false
        default: "true"
        type: choice
        options:
          - "true"
          - "false"
      deploy_backoffice:
        description: "Desplegar BackOffice (true/false)"
        required: false
        default: "true"
        type: choice
        options:
          - "true"
          - "false"
      deploy_frontoffice:
        description: "Desplegar FrontOffice (true/false)"
        required: false
        default: "true"
        type: choice
        options:
          - "true"
          - "false"
      run_update_services:
        description: "Forzar actualización de servicios ECS después del build (true/false)"
        required: false
        default: "true"
        type: choice
        options:
          - "true"
          - "false"

jobs:
  infra:
    name: Provision infra (Terraform)
    if: ${{ github.event.inputs.run_infra != 'false' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0

      - name: Terraform Init
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          TF_VAR_db_password: ${{ secrets.TF_VAR_db_password }}
          TF_VAR_jwt_secret: ${{ secrets.TF_VAR_jwt_secret }}
          TF_VAR_db_username: ${{ secrets.TF_VAR_db_username }}
        run: terraform init -input=false

      - name: Clean Terraform state conflicts
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          echo "Cleaning conflicting resources from Terraform state..."

          # Remove all resources from state to start fresh with imports
          terraform state rm aws_vpc.main 2>/dev/null || true
          terraform state rm aws_internet_gateway.main 2>/dev/null || true
          terraform state rm 'aws_subnet.public[0]' 2>/dev/null || true
          terraform state rm 'aws_subnet.public[1]' 2>/dev/null || true
          terraform state rm 'aws_subnet.private[0]' 2>/dev/null || true
          terraform state rm 'aws_subnet.private[1]' 2>/dev/null || true
          terraform state rm aws_route_table.public 2>/dev/null || true
          terraform state rm aws_route_table.private 2>/dev/null || true
          terraform state rm 'aws_route_table_association.public[0]' 2>/dev/null || true
          terraform state rm 'aws_route_table_association.public[1]' 2>/dev/null || true
          terraform state rm 'aws_route_table_association.private[0]' 2>/dev/null || true
          terraform state rm 'aws_route_table_association.private[1]' 2>/dev/null || true
          terraform state rm aws_security_group.alb 2>/dev/null || true
          terraform state rm aws_security_group.ecs_tasks 2>/dev/null || true
          terraform state rm aws_security_group.rds 2>/dev/null || true
          terraform state rm aws_lb.main 2>/dev/null || true
          terraform state rm aws_lb_target_group.api 2>/dev/null || true
          terraform state rm aws_lb_target_group.backoffice 2>/dev/null || true
          terraform state rm aws_lb_target_group.frontoffice 2>/dev/null || true
          terraform state rm aws_lb_listener.main 2>/dev/null || true
          terraform state rm aws_lb_listener_rule.api 2>/dev/null || true
          terraform state rm aws_lb_listener_rule.backoffice 2>/dev/null || true
          terraform state rm aws_lb_listener_rule.frontoffice 2>/dev/null || true
          terraform state rm aws_db_subnet_group.main 2>/dev/null || true
          terraform state rm aws_ecs_cluster.main 2>/dev/null || true
          terraform state rm aws_ecs_service.api 2>/dev/null || true
          terraform state rm aws_ecs_service.backoffice 2>/dev/null || true
          terraform state rm aws_ecs_service.frontoffice 2>/dev/null || true
          terraform state rm aws_ecs_task_definition.api 2>/dev/null || true
          terraform state rm aws_ecs_task_definition.backoffice 2>/dev/null || true
          terraform state rm aws_ecs_task_definition.frontoffice 2>/dev/null || true
          terraform state rm aws_db_instance.sqlserver 2>/dev/null || true

          echo "State cleanup completed!"

      - name: Import existing resources
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          TF_VAR_db_password: ${{ secrets.TF_VAR_db_password }}
          TF_VAR_jwt_secret: ${{ secrets.TF_VAR_jwt_secret }}
          TF_VAR_db_username: ${{ secrets.TF_VAR_db_username }}
        run: |
          echo "Importing existing resources to Terraform state..."

          # Import ECR Repositories
          terraform import aws_ecr_repository.api proyectonet-api 2>/dev/null || echo "api repo already imported or doesn't exist"
          terraform import aws_ecr_repository.backoffice proyectonet-backoffice 2>/dev/null || echo "backoffice repo already imported or doesn't exist"
          terraform import aws_ecr_repository.frontoffice proyectonet-frontoffice 2>/dev/null || echo "frontoffice repo already imported or doesn't exist"

          # Import CloudWatch Log Groups
          terraform import aws_cloudwatch_log_group.api /ecs/proyectonet-api 2>/dev/null || echo "api logs already imported or doesn't exist"
          terraform import aws_cloudwatch_log_group.backoffice /ecs/proyectonet-backoffice 2>/dev/null || echo "backoffice logs already imported or doesn't exist"
          terraform import aws_cloudwatch_log_group.frontoffice /ecs/proyectonet-frontoffice 2>/dev/null || echo "frontoffice logs already imported or doesn't exist"

          # Import ALB
          ALB_ARN=$(aws elbv2 describe-load-balancers --names proyectonet-alb --region $AWS_REGION --query 'LoadBalancers[0].LoadBalancerArn' --output text 2>/dev/null || echo "")
          if [ -n "$ALB_ARN" ] && [ "$ALB_ARN" != "None" ]; then
            terraform import aws_lb.main "$ALB_ARN" 2>/dev/null || echo "ALB already imported"

            # Import ALB Listeners
            LISTENER_ARN=$(aws elbv2 describe-listeners --load-balancer-arn "$ALB_ARN" --region $AWS_REGION --query 'Listeners[?Port==`80`].ListenerArn' --output text 2>/dev/null || echo "")
            if [ -n "$LISTENER_ARN" ] && [ "$LISTENER_ARN" != "None" ]; then
              terraform import aws_lb_listener.main "$LISTENER_ARN" 2>/dev/null || echo "Listener already imported"

              # Import Listener Rules
              # Get all listener rules for this listener
              RULES=$(aws elbv2 describe-rules --listener-arn "$LISTENER_ARN" --region $AWS_REGION --query 'Rules[?!IsDefault].RuleArn' --output text 2>/dev/null || echo "")
              if [ -n "$RULES" ]; then
                for RULE_ARN in $RULES; do
                  # Try to determine which rule this is based on priority
                  PRIORITY=$(aws elbv2 describe-rules --rule-arns "$RULE_ARN" --region $AWS_REGION --query 'Rules[0].Priority' --output text 2>/dev/null || echo "")

                  if [ "$PRIORITY" = "50" ]; then
                    terraform import aws_lb_listener_rule.api "$RULE_ARN" 2>/dev/null || echo "API rule already imported"
                  elif [ "$PRIORITY" = "75" ]; then
                    terraform import aws_lb_listener_rule.frontoffice "$RULE_ARN" 2>/dev/null || echo "FrontOffice rule already imported"
                  elif [ "$PRIORITY" = "100" ]; then
                    terraform import aws_lb_listener_rule.backoffice "$RULE_ARN" 2>/dev/null || echo "BackOffice rule already imported"
                  fi
                done
              fi
            fi
          fi

          # Import Target Groups
          API_TG_ARN=$(aws elbv2 describe-target-groups --names proyectonet-api-tg --region $AWS_REGION --query 'TargetGroups[0].TargetGroupArn' --output text 2>/dev/null || echo "")
          if [ -n "$API_TG_ARN" ] && [ "$API_TG_ARN" != "None" ]; then
            terraform import aws_lb_target_group.api "$API_TG_ARN" 2>/dev/null || echo "API TG already imported"
          fi

          BACKOFFICE_TG_ARN=$(aws elbv2 describe-target-groups --names proyectonet-backoffice-tg --region $AWS_REGION --query 'TargetGroups[0].TargetGroupArn' --output text 2>/dev/null || echo "")
          if [ -n "$BACKOFFICE_TG_ARN" ] && [ "$BACKOFFICE_TG_ARN" != "None" ]; then
            terraform import aws_lb_target_group.backoffice "$BACKOFFICE_TG_ARN" 2>/dev/null || echo "BackOffice TG already imported"
          fi

          FRONTOFFICE_TG_ARN=$(aws elbv2 describe-target-groups --names proyectonet-frontoffice-tg --region $AWS_REGION --query 'TargetGroups[0].TargetGroupArn' --output text 2>/dev/null || echo "")
          if [ -n "$FRONTOFFICE_TG_ARN" ] && [ "$FRONTOFFICE_TG_ARN" != "None" ]; then
            terraform import aws_lb_target_group.frontoffice "$FRONTOFFICE_TG_ARN" 2>/dev/null || echo "FrontOffice TG already imported"
          fi

          # Import DB Subnet Group
          terraform import aws_db_subnet_group.main proyectonet-db-subnet-group 2>/dev/null || echo "DB subnet group already imported or doesn't exist"

          # Import VPC
          VPC_ID=$(aws ec2 describe-vpcs --filters "Name=tag:Name,Values=proyectonet-vpc" --region $AWS_REGION --query 'Vpcs[0].VpcId' --output text 2>/dev/null || echo "")
          if [ -n "$VPC_ID" ] && [ "$VPC_ID" != "None" ]; then
            terraform import aws_vpc.main "$VPC_ID" 2>/dev/null || echo "VPC already imported"
          fi

          # Import Internet Gateway
          IGW_ID=$(aws ec2 describe-internet-gateways --filters "Name=tag:Name,Values=proyectonet-igw" --region $AWS_REGION --query 'InternetGateways[0].InternetGatewayId' --output text 2>/dev/null || echo "")
          if [ -n "$IGW_ID" ] && [ "$IGW_ID" != "None" ]; then
            terraform import aws_internet_gateway.main "$IGW_ID" 2>/dev/null || echo "IGW already imported"
          fi

          # Import Security Groups
          ALB_SG_ID=$(aws ec2 describe-security-groups --filters "Name=tag:Name,Values=proyectonet-alb-sg" --region $AWS_REGION --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || echo "")
          if [ -n "$ALB_SG_ID" ] && [ "$ALB_SG_ID" != "None" ]; then
            terraform import aws_security_group.alb "$ALB_SG_ID" 2>/dev/null || echo "ALB SG already imported"
          fi

          ECS_SG_ID=$(aws ec2 describe-security-groups --filters "Name=tag:Name,Values=proyectonet-ecs-tasks-sg" --region $AWS_REGION --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || echo "")
          if [ -n "$ECS_SG_ID" ] && [ "$ECS_SG_ID" != "None" ]; then
            terraform import aws_security_group.ecs_tasks "$ECS_SG_ID" 2>/dev/null || echo "ECS tasks SG already imported"
          fi

          RDS_SG_ID=$(aws ec2 describe-security-groups --filters "Name=tag:Name,Values=proyectonet-rds-sg" --region $AWS_REGION --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || echo "")
          if [ -n "$RDS_SG_ID" ] && [ "$RDS_SG_ID" != "None" ]; then
            terraform import aws_security_group.rds "$RDS_SG_ID" 2>/dev/null || echo "RDS SG already imported"
          fi

          # Import Subnets
          PUBLIC_SUBNETS=$(aws ec2 describe-subnets --filters "Name=tag:Name,Values=proyectonet-public-subnet-*" --region $AWS_REGION --query 'Subnets[*].SubnetId' --output text 2>/dev/null || echo "")
          if [ -n "$PUBLIC_SUBNETS" ]; then
            idx=0
            for subnet_id in $PUBLIC_SUBNETS; do
              terraform import "aws_subnet.public[$idx]" "$subnet_id" 2>/dev/null || echo "Public subnet $idx already imported"
              idx=$((idx + 1))
            done
          fi

          PRIVATE_SUBNETS=$(aws ec2 describe-subnets --filters "Name=tag:Name,Values=proyectonet-private-subnet-*" --region $AWS_REGION --query 'Subnets[*].SubnetId' --output text 2>/dev/null || echo "")
          if [ -n "$PRIVATE_SUBNETS" ]; then
            idx=0
            for subnet_id in $PRIVATE_SUBNETS; do
              terraform import "aws_subnet.private[$idx]" "$subnet_id" 2>/dev/null || echo "Private subnet $idx already imported"
              idx=$((idx + 1))
            done
          fi

          # Import Route Tables
          PUBLIC_RT_ID=$(aws ec2 describe-route-tables --filters "Name=tag:Name,Values=proyectonet-public-rt" --region $AWS_REGION --query 'RouteTables[0].RouteTableId' --output text 2>/dev/null || echo "")
          if [ -n "$PUBLIC_RT_ID" ] && [ "$PUBLIC_RT_ID" != "None" ]; then
            terraform import aws_route_table.public "$PUBLIC_RT_ID" 2>/dev/null || echo "Public RT already imported"
          fi

          PRIVATE_RT_ID=$(aws ec2 describe-route-tables --filters "Name=tag:Name,Values=proyectonet-private-rt" --region $AWS_REGION --query 'RouteTables[0].RouteTableId' --output text 2>/dev/null || echo "")
          if [ -n "$PRIVATE_RT_ID" ] && [ "$PRIVATE_RT_ID" != "None" ]; then
            terraform import aws_route_table.private "$PRIVATE_RT_ID" 2>/dev/null || echo "Private RT already imported"
          fi

          # Import ECS Cluster
          CLUSTER_ARN=$(aws ecs describe-clusters --clusters proyectonet-cluster --region $AWS_REGION --query 'clusters[0].clusterArn' --output text 2>/dev/null || echo "")
          if [ -n "$CLUSTER_ARN" ] && [ "$CLUSTER_ARN" != "None" ] && [ "$CLUSTER_ARN" != "null" ]; then
            terraform import aws_ecs_cluster.main "$CLUSTER_ARN" 2>/dev/null || echo "ECS cluster already imported"
          fi

          # Import ECS Services
          API_SERVICE=$(aws ecs describe-services --cluster proyectonet-cluster --services proyectonet-api-service --region $AWS_REGION --query 'services[0].serviceArn' --output text 2>/dev/null || echo "")
          if [ -n "$API_SERVICE" ] && [ "$API_SERVICE" != "None" ] && [ "$API_SERVICE" != "null" ]; then
            terraform import aws_ecs_service.api "$API_SERVICE" 2>/dev/null || echo "API service already imported"
          fi

          BACKOFFICE_SERVICE=$(aws ecs describe-services --cluster proyectonet-cluster --services proyectonet-backoffice-service --region $AWS_REGION --query 'services[0].serviceArn' --output text 2>/dev/null || echo "")
          if [ -n "$BACKOFFICE_SERVICE" ] && [ "$BACKOFFICE_SERVICE" != "None" ] && [ "$BACKOFFICE_SERVICE" != "null" ]; then
            terraform import aws_ecs_service.backoffice "$BACKOFFICE_SERVICE" 2>/dev/null || echo "BackOffice service already imported"
          fi

          FRONTOFFICE_SERVICE=$(aws ecs describe-services --cluster proyectonet-cluster --services proyectonet-frontoffice-service --region $AWS_REGION --query 'services[0].serviceArn' --output text 2>/dev/null || echo "")
          if [ -n "$FRONTOFFICE_SERVICE" ] && [ "$FRONTOFFICE_SERVICE" != "None" ] && [ "$FRONTOFFICE_SERVICE" != "null" ]; then
            terraform import aws_ecs_service.frontoffice "$FRONTOFFICE_SERVICE" 2>/dev/null || echo "FrontOffice service already imported"
          fi

          # Import ECS Task Definitions (latest revision)
          API_TASK_DEF=$(aws ecs describe-task-definition --task-definition proyectonet-api --region $AWS_REGION --query 'taskDefinition.taskDefinitionArn' --output text 2>/dev/null || echo "")
          if [ -n "$API_TASK_DEF" ] && [ "$API_TASK_DEF" != "None" ] && [ "$API_TASK_DEF" != "null" ]; then
            terraform import aws_ecs_task_definition.api "$API_TASK_DEF" 2>/dev/null || echo "API task definition already imported"
          fi

          BACKOFFICE_TASK_DEF=$(aws ecs describe-task-definition --task-definition proyectonet-backoffice --region $AWS_REGION --query 'taskDefinition.taskDefinitionArn' --output text 2>/dev/null || echo "")
          if [ -n "$BACKOFFICE_TASK_DEF" ] && [ "$BACKOFFICE_TASK_DEF" != "None" ] && [ "$BACKOFFICE_TASK_DEF" != "null" ]; then
            terraform import aws_ecs_task_definition.backoffice "$BACKOFFICE_TASK_DEF" 2>/dev/null || echo "BackOffice task definition already imported"
          fi

          FRONTOFFICE_TASK_DEF=$(aws ecs describe-task-definition --task-definition proyectonet-frontoffice --region $AWS_REGION --query 'taskDefinition.taskDefinitionArn' --output text 2>/dev/null || echo "")
          if [ -n "$FRONTOFFICE_TASK_DEF" ] && [ "$FRONTOFFICE_TASK_DEF" != "None" ] && [ "$FRONTOFFICE_TASK_DEF" != "null" ]; then
            terraform import aws_ecs_task_definition.frontoffice "$FRONTOFFICE_TASK_DEF" 2>/dev/null || echo "FrontOffice task definition already imported"
          fi

          # Import RDS Instance if exists
          RDS_ID=$(aws rds describe-db-instances --db-instance-identifier proyectonet-sqlserver --region $AWS_REGION --query 'DBInstances[0].DBInstanceIdentifier' --output text 2>/dev/null || echo "")
          if [ -n "$RDS_ID" ] && [ "$RDS_ID" != "None" ]; then
            terraform import aws_db_instance.sqlserver "$RDS_ID" 2>/dev/null || echo "RDS instance already imported"
          fi

          echo "Import process completed!"

      - name: Terraform Validate
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          TF_VAR_db_password: ${{ secrets.TF_VAR_db_password }}
          TF_VAR_jwt_secret: ${{ secrets.TF_VAR_jwt_secret }}
          TF_VAR_db_username: ${{ secrets.TF_VAR_db_username }}
        run: terraform validate || true

      - name: Terraform Apply
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          TF_VAR_db_password: ${{ secrets.TF_VAR_db_password }}
          TF_VAR_jwt_secret: ${{ secrets.TF_VAR_jwt_secret }}
          TF_VAR_db_username: ${{ secrets.TF_VAR_db_username }}
        run: terraform apply -auto-approve -input=false

  build:
    name: Build & push images
    runs-on: ubuntu-latest
    env:
      ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com
      API_REPO: proyectonet-api
      BACKOFFICE_REPO: proyectonet-backoffice
      FRONTOFFICE_REPO: proyectonet-frontoffice
      IMAGE_TAG: latest
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v1
        with:
          mask-password: true

      - name: Build and push Docker image for BackOffice
        if: ${{ github.event.inputs.deploy_backoffice != 'false' }}
        env:
          ECR_REGISTRY: ${{ env.ECR_REGISTRY }}
          BACKOFFICE_REPO: ${{ env.BACKOFFICE_REPO }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
        run: |
          echo "Building BackOffice using root Dockerfile (target final-backoffice)"
          docker build -t ${BACKOFFICE_REPO}:${IMAGE_TAG} --target final-backoffice -f Dockerfile .
          docker tag ${BACKOFFICE_REPO}:${IMAGE_TAG} ${ECR_REGISTRY}/${BACKOFFICE_REPO}:${IMAGE_TAG}
          docker push ${ECR_REGISTRY}/${BACKOFFICE_REPO}:${IMAGE_TAG}

      - name: Build and push Docker image for FrontOffice
        if: ${{ github.event.inputs.deploy_frontoffice != 'false' }}
        env:
          ECR_REGISTRY: ${{ env.ECR_REGISTRY }}
          FRONTOFFICE_REPO: ${{ env.FRONTOFFICE_REPO }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
        run: |
          echo "Building FrontOffice using root Dockerfile (target final-frontoffice)"
          docker build -t ${FRONTOFFICE_REPO}:${IMAGE_TAG} --target final-frontoffice -f Dockerfile .
          docker tag ${FRONTOFFICE_REPO}:${IMAGE_TAG} ${ECR_REGISTRY}/${FRONTOFFICE_REPO}:${IMAGE_TAG}
          docker push ${ECR_REGISTRY}/${FRONTOFFICE_REPO}:${IMAGE_TAG}

      - name: Build and push Docker image for API
        if: ${{ github.event.inputs.deploy_api != 'false' }}
        env:
          ECR_REGISTRY: ${{ env.ECR_REGISTRY }}
          API_REPO: ${{ env.API_REPO }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          RECREATE_DATABASE: ${{ github.event.inputs.recreate_db }}
        run: |
          echo "Building API using root Dockerfile (target final-api)"
          docker build -t ${API_REPO}:${IMAGE_TAG} --target final-api -f Dockerfile --build-arg RECREATE_DATABASE=${RECREATE_DATABASE} .
          docker tag ${API_REPO}:${IMAGE_TAG} ${ECR_REGISTRY}/${API_REPO}:${IMAGE_TAG}
          docker push ${ECR_REGISTRY}/${API_REPO}:${IMAGE_TAG}

  update-services:
    name: Update ECS services
    if: ${{ github.event.inputs.run_update_services != 'false' }}
    needs: build
    runs-on: ubuntu-latest
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install awscli and jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq unzip curl
          echo "Installing or updating AWS CLI v2..."
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip awscliv2.zip
          # Use --update so installer succeeds whether AWS CLI v2 is already present or not
          sudo ./aws/install --update || sudo ./aws/install
          aws --version
          # cleanup
          rm -rf awscliv2.zip aws/

      - name: Update ECS services to force new deployment
        run: |
          set -euo pipefail
          echo "Detecting ECS cluster..."
          clusters_json=$(aws ecs list-clusters --region "$AWS_REGION" --output json)
          clusterArn=$(echo "$clusters_json" | jq -r '.clusterArns[]' | grep -i "proyectonet" || true)
          if [ -z "$clusterArn" ]; then
            clusterArn=$(echo "$clusters_json" | jq -r '.clusterArns[0]')
          fi
          if [ -z "$clusterArn" ] || [ "$clusterArn" = "null" ]; then
            echo "No ECS cluster found. Skipping service update.";
            exit 0;
          fi
          clusterName=$(basename "$clusterArn")
          echo "Using cluster: $clusterName"

          services_json=$(aws ecs list-services --cluster "$clusterName" --region "$AWS_REGION" --output json)
          for svc in $(echo "$services_json" | jq -r '.serviceArns[]'); do
            svcName=$(basename "$svc")
            echo "Checking service: $svcName"
            if echo "$svcName" | grep -qi "backoffice" || echo "$svcName" | grep -qi "api" || echo "$svcName" | grep -qi "frontoffice"; then
              echo "Forcing new deployment for $svcName"
              aws ecs update_service --cluster "$clusterName" --service "$svcName" --force-new-deployment --region "$AWS_REGION"
            else
              echo "Skipping $svcName"
            fi
          done

  report:
    name: Report deployment URL
    needs: [infra, build, update-services]
    runs-on: ubuntu-latest
    if: always()
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install AWS CLI and jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq unzip curl
          echo "Installing or updating AWS CLI v2..."
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip awscliv2.zip
          # Use --update so installer succeeds whether AWS CLI v2 is already present or not
          sudo ./aws/install --update || sudo ./aws/install
          aws --version
          rm -rf awscliv2.zip aws/

      - name: Get ALB DNS and produce deploy URLs
        id: get_urls
        run: |
          set -euo pipefail
          ALB_NAME="proyectonet-alb"
          echo "Looking for ALB: $ALB_NAME"
          dns=""
          # try by exact name
          dns=$(aws elbv2 describe-load-balancers --names "$ALB_NAME" --region "$AWS_REGION" --output text --query 'LoadBalancers[0].DNSName' 2>/dev/null || true)
          if [ -z "$dns" ]; then
            echo "ALB not found by exact name, searching all ALBs for proyectonet..."
            dns=$(aws elbv2 describe-load-balancers --region "$AWS_REGION" --query 'LoadBalancers[?contains(LoadBalancerName, `proyectonet`)].DNSName' --output text || true)
          fi

          if [ -n "$dns" ] && [ "$dns" != "None" ]; then
            echo "Found ALB DNS: $dns"

            # Construct URLs for all services
            backoffice_url="http://$dns"
            frontoffice_url="http://$dns/frontoffice"
            api_url="http://$dns/api"

            echo "BackOffice URL: $backoffice_url"
            echo "FrontOffice URL: $frontoffice_url"
            echo "API URL: $api_url"

            # Save to GitHub outputs
            echo "backoffice_url=$backoffice_url" >> $GITHUB_OUTPUT
            echo "frontoffice_url=$frontoffice_url" >> $GITHUB_OUTPUT
            echo "api_url=$api_url" >> $GITHUB_OUTPUT
            echo "alb_dns=$dns" >> $GITHUB_OUTPUT
          else
            echo "No ALB DNS found via AWS CLI. Trying terraform state file as fallback..."
            if [ -f terraform/terraform.tfstate ]; then
              backoffice_url=$(jq -r '.outputs.backoffice_url.value' terraform/terraform.tfstate 2>/dev/null || echo "NOT_FOUND")
              frontoffice_url=$(jq -r '.outputs.frontoffice_url.value' terraform/terraform.tfstate 2>/dev/null || echo "NOT_FOUND")
              api_url=$(jq -r '.outputs.api_url.value' terraform/terraform.tfstate 2>/dev/null || echo "NOT_FOUND")

              echo "backoffice_url=$backoffice_url" >> $GITHUB_OUTPUT
              echo "frontoffice_url=$frontoffice_url" >> $GITHUB_OUTPUT
              echo "api_url=$api_url" >> $GITHUB_OUTPUT
              echo "alb_dns=NOT_FOUND" >> $GITHUB_OUTPUT
            else
              echo "terraform.tfstate not present in repository"
              echo "backoffice_url=NOT_FOUND" >> $GITHUB_OUTPUT
              echo "frontoffice_url=NOT_FOUND" >> $GITHUB_OUTPUT
              echo "api_url=NOT_FOUND" >> $GITHUB_OUTPUT
              echo "alb_dns=NOT_FOUND" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Show deployment URLs
        run: |
          echo "=========================================="
          echo "  DEPLOYMENT COMPLETED SUCCESSFULLY"
          echo "=========================================="
          echo ""
          echo "📍 ALB DNS: ${{ steps.get_urls.outputs.alb_dns }}"
          echo ""
          echo "🌐 Application URLs:"
          echo "   • BackOffice:  ${{ steps.get_urls.outputs.backoffice_url }}"
          echo "   • FrontOffice: ${{ steps.get_urls.outputs.frontoffice_url }}"
          echo "   • API:         ${{ steps.get_urls.outputs.api_url }}"
          echo ""
          echo "=========================================="
          echo ""

      - name: Write deployment URLs to file
        if: always()
        run: |
          cat > deployment-urls.txt << EOF
          ========================================
          DEPLOYMENT URLS
          ========================================

          ALB DNS: ${{ steps.get_urls.outputs.alb_dns }}

          BackOffice URL:  ${{ steps.get_urls.outputs.backoffice_url }}
          FrontOffice URL: ${{ steps.get_urls.outputs.frontoffice_url }}
          API URL:         ${{ steps.get_urls.outputs.api_url }}

          ========================================
          EOF

      - name: Upload deployment URLs artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-urls
          path: deployment-urls.txt

    outputs:
      backoffice_url: ${{ steps.get_urls.outputs.backoffice_url }}
      frontoffice_url: ${{ steps.get_urls.outputs.frontoffice_url }}
      api_url: ${{ steps.get_urls.outputs.api_url }}
      alb_dns: ${{ steps.get_urls.outputs.alb_dns }}
