name: CI/CD Pipeline

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: "Ambiente de despliegue (production, staging, etc.)"
        required: false
        default: "production"
      recreate_db:
        description: "Recrear base de datos (true/false)"
        required: false
        default: "false"
      deploy_api:
        description: "Desplegar API (true/false)"
        required: false
        default: "true"
      deploy_backoffice:
        description: "Desplegar BackOffice (true/false)"
        required: false
        default: "true"

jobs:
  infra:
    name: Provision infra (Terraform)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0

      - name: Terraform Init
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: terraform init

      - name: Terraform Validate
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: terraform validate || true

      - name: Terraform Apply
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: terraform apply -auto-approve

  build:
    name: Build & push images
    needs: infra
    runs-on: ubuntu-latest
    env:
      ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com
      API_REPO: proyectonet-api
      BACKOFFICE_REPO: proyectonet-backoffice
      IMAGE_TAG: latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v1
        with:
          mask-password: true
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}

      - name: Build and push Docker image for BackOffice
        if: ${{ github.event.inputs.deploy_backoffice != 'false' }}
        env:
          ECR_REGISTRY: ${{ env.ECR_REGISTRY }}
          BACKOFFICE_REPO: ${{ env.BACKOFFICE_REPO }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
        run: |
          echo "Building BackOffice using root Dockerfile (target final-backoffice)"
          docker build -t ${BACKOFFICE_REPO}:${IMAGE_TAG} --target final-backoffice -f Dockerfile .
          docker tag ${BACKOFFICE_REPO}:${IMAGE_TAG} ${ECR_REGISTRY}/${BACKOFFICE_REPO}:${IMAGE_TAG}
          docker push ${ECR_REGISTRY}/${BACKOFFICE_REPO}:${IMAGE_TAG}

      - name: Build and push Docker image for API
        if: ${{ github.event.inputs.deploy_api != 'false' }}
        env:
          ECR_REGISTRY: ${{ env.ECR_REGISTRY }}
          API_REPO: ${{ env.API_REPO }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          RECREATE_DATABASE: ${{ github.event.inputs.recreate_db }}
        run: |
          echo "Building API using root Dockerfile (target final-api)"
          docker build -t ${API_REPO}:${IMAGE_TAG} --target final-api -f Dockerfile --build-arg RECREATE_DATABASE=${RECREATE_DATABASE} .
          docker tag ${API_REPO}:${IMAGE_TAG} ${ECR_REGISTRY}/${API_REPO}:${IMAGE_TAG}
          docker push ${ECR_REGISTRY}/${API_REPO}:${IMAGE_TAG}

  update-services:
    name: Update ECS services
    needs: build
    runs-on: ubuntu-latest
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install awscli and jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq awscli

      - name: Update ECS services to force new deployment
        run: |
          set -euo pipefail
          echo "Detecting ECS cluster..."
          clusters_json=$(aws ecs list-clusters --region "$AWS_REGION" --output json)
          clusterArn=$(echo "$clusters_json" | jq -r '.clusterArns[]' | grep -i "proyectonet" || true)
          if [ -z "$clusterArn" ]; then
            clusterArn=$(echo "$clusters_json" | jq -r '.clusterArns[0]')
          fi
          if [ -z "$clusterArn" ] || [ "$clusterArn" = "null" ]; then
            echo "No ECS cluster found. Skipping service update.";
            exit 0;
          fi
          clusterName=$(basename "$clusterArn")
          echo "Using cluster: $clusterName"

          services_json=$(aws ecs list-services --cluster "$clusterName" --region "$AWS_REGION" --output json)
          for svc in $(echo "$services_json" | jq -r '.serviceArns[]'); do
            svcName=$(basename "$svc")
            echo "Checking service: $svcName"
            if echo "$svcName" | grep -qi "backoffice" || echo "$svcName" | grep -qi "api"; then
              echo "Forcing new deployment for $svcName"
              aws ecs update-service --cluster "$clusterName" --service "$svcName" --force-new-deployment --region "$AWS_REGION"
            else
              echo "Skipping $svcName"
            fi
          done
