name: CI/CD Pipeline

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Ambiente de despliegue (production, staging, etc.)"
        required: false
        default: "production"
        type: choice
        options:
          - production
          - staging
          - development
      run_infra:
        description: "Ejecutar provisioning de infra con Terraform (true/false)"
        required: false
        default: "true"
        type: choice
        options:
          - "true"
          - "false"
      recreate_db:
        description: "Recrear base de datos (true/false)"
        required: false
        default: "false"
        type: choice
        options:
          - "true"
          - "false"
      deploy_api:
        description: "Desplegar API (true/false)"
        required: false
        default: "true"
        type: choice
        options:
          - "true"
          - "false"
      deploy_backoffice:
        description: "Desplegar BackOffice (true/false)"
        required: false
        default: "true"
        type: choice
        options:
          - "true"
          - "false"
      deploy_frontoffice:
        description: "Desplegar FrontOffice (true/false)"
        required: false
        default: "true"
        type: choice
        options:
          - "true"
          - "false"
      run_update_services:
        description: "Forzar actualización de servicios ECS después del build (true/false)"
        required: false
        default: "true"
        type: choice
        options:
          - "true"
          - "false"

jobs:
  infra:
    name: Provision infra (Terraform)
    if: ${{ github.event.inputs.run_infra != 'false' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0

      - name: Terraform Init
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          TF_VAR_db_password: ${{ secrets.TF_VAR_db_password }}
          TF_VAR_jwt_secret: ${{ secrets.TF_VAR_jwt_secret }}
          TF_VAR_db_username: ${{ secrets.TF_VAR_db_username }}
        run: terraform init -input=false

      - name: Import existing resources
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          TF_VAR_db_password: ${{ secrets.TF_VAR_db_password }}
          TF_VAR_jwt_secret: ${{ secrets.TF_VAR_jwt_secret }}
          TF_VAR_db_username: ${{ secrets.TF_VAR_db_username }}
        run: |
          echo "Importing existing resources to Terraform state..."

          # Import ECR Repositories
          terraform import aws_ecr_repository.api proyectonet-api 2>/dev/null || echo "api repo already imported or doesn't exist"
          terraform import aws_ecr_repository.backoffice proyectonet-backoffice 2>/dev/null || echo "backoffice repo already imported or doesn't exist"
          terraform import aws_ecr_repository.frontoffice proyectonet-frontoffice 2>/dev/null || echo "frontoffice repo already imported or doesn't exist"

          # Import CloudWatch Log Groups
          terraform import aws_cloudwatch_log_group.api /ecs/proyectonet-api 2>/dev/null || echo "api logs already imported or doesn't exist"
          terraform import aws_cloudwatch_log_group.backoffice /ecs/proyectonet-backoffice 2>/dev/null || echo "backoffice logs already imported or doesn't exist"
          terraform import aws_cloudwatch_log_group.frontoffice /ecs/proyectonet-frontoffice 2>/dev/null || echo "frontoffice logs already imported or doesn't exist"

          # Import ALB
          ALB_ARN=$(aws elbv2 describe-load-balancers --names proyectonet-alb --region $AWS_REGION --query 'LoadBalancers[0].LoadBalancerArn' --output text 2>/dev/null || echo "")
          if [ -n "$ALB_ARN" ] && [ "$ALB_ARN" != "None" ]; then
            terraform import aws_lb.main "$ALB_ARN" 2>/dev/null || echo "ALB already imported"
          fi

          # Import Target Groups
          API_TG_ARN=$(aws elbv2 describe-target-groups --names proyectonet-api-tg --region $AWS_REGION --query 'TargetGroups[0].TargetGroupArn' --output text 2>/dev/null || echo "")
          if [ -n "$API_TG_ARN" ] && [ "$API_TG_ARN" != "None" ]; then
            terraform import aws_lb_target_group.api "$API_TG_ARN" 2>/dev/null || echo "API TG already imported"
          fi

          BACKOFFICE_TG_ARN=$(aws elbv2 describe-target-groups --names proyectonet-backoffice-tg --region $AWS_REGION --query 'TargetGroups[0].TargetGroupArn' --output text 2>/dev/null || echo "")
          if [ -n "$BACKOFFICE_TG_ARN" ] && [ "$BACKOFFICE_TG_ARN" != "None" ]; then
            terraform import aws_lb_target_group.backoffice "$BACKOFFICE_TG_ARN" 2>/dev/null || echo "BackOffice TG already imported"
          fi

          FRONTOFFICE_TG_ARN=$(aws elbv2 describe-target-groups --names proyectonet-frontoffice-tg --region $AWS_REGION --query 'TargetGroups[0].TargetGroupArn' --output text 2>/dev/null || echo "")
          if [ -n "$FRONTOFFICE_TG_ARN" ] && [ "$FRONTOFFICE_TG_ARN" != "None" ]; then
            terraform import aws_lb_target_group.frontoffice "$FRONTOFFICE_TG_ARN" 2>/dev/null || echo "FrontOffice TG already imported"
          fi

          # Import DB Subnet Group
          terraform import aws_db_subnet_group.main proyectonet-db-subnet-group 2>/dev/null || echo "DB subnet group already imported or doesn't exist"

          echo "Import process completed!"

      - name: Terraform Validate
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          TF_VAR_db_password: ${{ secrets.TF_VAR_db_password }}
          TF_VAR_jwt_secret: ${{ secrets.TF_VAR_jwt_secret }}
          TF_VAR_db_username: ${{ secrets.TF_VAR_db_username }}
        run: terraform validate || true

      - name: Terraform Apply
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          TF_VAR_db_password: ${{ secrets.TF_VAR_db_password }}
          TF_VAR_jwt_secret: ${{ secrets.TF_VAR_jwt_secret }}
          TF_VAR_db_username: ${{ secrets.TF_VAR_db_username }}
        run: terraform apply -auto-approve -input=false

  build:
    name: Build & push images
    runs-on: ubuntu-latest
    env:
      ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com
      API_REPO: proyectonet-api
      BACKOFFICE_REPO: proyectonet-backoffice
      FRONTOFFICE_REPO: proyectonet-frontoffice
      IMAGE_TAG: latest
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v1
        with:
          mask-password: true

      - name: Build and push Docker image for BackOffice
        if: ${{ github.event.inputs.deploy_backoffice != 'false' }}
        env:
          ECR_REGISTRY: ${{ env.ECR_REGISTRY }}
          BACKOFFICE_REPO: ${{ env.BACKOFFICE_REPO }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
        run: |
          echo "Building BackOffice using root Dockerfile (target final-backoffice)"
          docker build -t ${BACKOFFICE_REPO}:${IMAGE_TAG} --target final-backoffice -f Dockerfile .
          docker tag ${BACKOFFICE_REPO}:${IMAGE_TAG} ${ECR_REGISTRY}/${BACKOFFICE_REPO}:${IMAGE_TAG}
          docker push ${ECR_REGISTRY}/${BACKOFFICE_REPO}:${IMAGE_TAG}

      - name: Build and push Docker image for FrontOffice
        if: ${{ github.event.inputs.deploy_frontoffice != 'false' }}
        env:
          ECR_REGISTRY: ${{ env.ECR_REGISTRY }}
          FRONTOFFICE_REPO: ${{ env.FRONTOFFICE_REPO }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
        run: |
          echo "Building FrontOffice using root Dockerfile (target final-frontoffice)"
          docker build -t ${FRONTOFFICE_REPO}:${IMAGE_TAG} --target final-frontoffice -f Dockerfile .
          docker tag ${FRONTOFFICE_REPO}:${IMAGE_TAG} ${ECR_REGISTRY}/${FRONTOFFICE_REPO}:${IMAGE_TAG}
          docker push ${ECR_REGISTRY}/${FRONTOFFICE_REPO}:${IMAGE_TAG}

      - name: Build and push Docker image for API
        if: ${{ github.event.inputs.deploy_api != 'false' }}
        env:
          ECR_REGISTRY: ${{ env.ECR_REGISTRY }}
          API_REPO: ${{ env.API_REPO }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          RECREATE_DATABASE: ${{ github.event.inputs.recreate_db }}
        run: |
          echo "Building API using root Dockerfile (target final-api)"
          docker build -t ${API_REPO}:${IMAGE_TAG} --target final-api -f Dockerfile --build-arg RECREATE_DATABASE=${RECREATE_DATABASE} .
          docker tag ${API_REPO}:${IMAGE_TAG} ${ECR_REGISTRY}/${API_REPO}:${IMAGE_TAG}
          docker push ${ECR_REGISTRY}/${API_REPO}:${IMAGE_TAG}

  update-services:
    name: Update ECS services
    if: ${{ github.event.inputs.run_update_services != 'false' }}
    needs: build
    runs-on: ubuntu-latest
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install awscli and jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq unzip curl
          echo "Installing or updating AWS CLI v2..."
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip awscliv2.zip
          # Use --update so installer succeeds whether AWS CLI v2 is already present or not
          sudo ./aws/install --update || sudo ./aws/install
          aws --version
          # cleanup
          rm -rf awscliv2.zip aws/

      - name: Update ECS services to force new deployment
        run: |
          set -euo pipefail
          echo "Detecting ECS cluster..."
          clusters_json=$(aws ecs list-clusters --region "$AWS_REGION" --output json)
          clusterArn=$(echo "$clusters_json" | jq -r '.clusterArns[]' | grep -i "proyectonet" || true)
          if [ -z "$clusterArn" ]; then
            clusterArn=$(echo "$clusters_json" | jq -r '.clusterArns[0]')
          fi
          if [ -z "$clusterArn" ] || [ "$clusterArn" = "null" ]; then
            echo "No ECS cluster found. Skipping service update.";
            exit 0;
          fi
          clusterName=$(basename "$clusterArn")
          echo "Using cluster: $clusterName"

          services_json=$(aws ecs list-services --cluster "$clusterName" --region "$AWS_REGION" --output json)
          for svc in $(echo "$services_json" | jq -r '.serviceArns[]'); do
            svcName=$(basename "$svc")
            echo "Checking service: $svcName"
            if echo "$svcName" | grep -qi "backoffice" || echo "$svcName" | grep -qi "api" || echo "$svcName" | grep -qi "frontoffice"; then
              echo "Forcing new deployment for $svcName"
              aws ecs update-service --cluster "$clusterName" --service "$svcName" --force-new-deployment --region "$AWS_REGION"
            else
              echo "Skipping $svcName"
            fi
          done

  report:
    name: Report deployment URL
    needs: [infra, build, update-services]
    runs-on: ubuntu-latest
    if: always()
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install AWS CLI and jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq unzip curl
          echo "Installing or updating AWS CLI v2..."
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip awscliv2.zip
          # Use --update so installer succeeds whether AWS CLI v2 is already present or not
          sudo ./aws/install --update || sudo ./aws/install
          aws --version
          rm -rf awscliv2.zip aws/

      - name: Get ALB DNS and produce deploy URLs
        id: get_urls
        run: |
          set -euo pipefail
          ALB_NAME="proyectonet-alb"
          echo "Looking for ALB: $ALB_NAME"
          dns=""
          # try by exact name
          dns=$(aws elbv2 describe-load-balancers --names "$ALB_NAME" --region "$AWS_REGION" --output text --query 'LoadBalancers[0].DNSName' 2>/dev/null || true)
          if [ -z "$dns" ]; then
            echo "ALB not found by exact name, searching all ALBs for proyectonet..."
            dns=$(aws elbv2 describe-load-balancers --region "$AWS_REGION" --query 'LoadBalancers[?contains(LoadBalancerName, `proyectonet`)].DNSName' --output text || true)
          fi

          if [ -n "$dns" ] && [ "$dns" != "None" ]; then
            echo "Found ALB DNS: $dns"

            # Construct URLs for all services
            backoffice_url="http://$dns"
            frontoffice_url="http://$dns/frontoffice"
            api_url="http://$dns/api"

            echo "BackOffice URL: $backoffice_url"
            echo "FrontOffice URL: $frontoffice_url"
            echo "API URL: $api_url"

            # Save to GitHub outputs
            echo "backoffice_url=$backoffice_url" >> $GITHUB_OUTPUT
            echo "frontoffice_url=$frontoffice_url" >> $GITHUB_OUTPUT
            echo "api_url=$api_url" >> $GITHUB_OUTPUT
            echo "alb_dns=$dns" >> $GITHUB_OUTPUT
          else
            echo "No ALB DNS found via AWS CLI. Trying terraform state file as fallback..."
            if [ -f terraform/terraform.tfstate ]; then
              backoffice_url=$(jq -r '.outputs.backoffice_url.value' terraform/terraform.tfstate 2>/dev/null || echo "NOT_FOUND")
              frontoffice_url=$(jq -r '.outputs.frontoffice_url.value' terraform/terraform.tfstate 2>/dev/null || echo "NOT_FOUND")
              api_url=$(jq -r '.outputs.api_url.value' terraform/terraform.tfstate 2>/dev/null || echo "NOT_FOUND")

              echo "backoffice_url=$backoffice_url" >> $GITHUB_OUTPUT
              echo "frontoffice_url=$frontoffice_url" >> $GITHUB_OUTPUT
              echo "api_url=$api_url" >> $GITHUB_OUTPUT
              echo "alb_dns=NOT_FOUND" >> $GITHUB_OUTPUT
            else
              echo "terraform.tfstate not present in repository"
              echo "backoffice_url=NOT_FOUND" >> $GITHUB_OUTPUT
              echo "frontoffice_url=NOT_FOUND" >> $GITHUB_OUTPUT
              echo "api_url=NOT_FOUND" >> $GITHUB_OUTPUT
              echo "alb_dns=NOT_FOUND" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Show deployment URLs
        run: |
          echo "=========================================="
          echo "  DEPLOYMENT COMPLETED SUCCESSFULLY"
          echo "=========================================="
          echo ""
          echo "📍 ALB DNS: ${{ steps.get_urls.outputs.alb_dns }}"
          echo ""
          echo "🌐 Application URLs:"
          echo "   • BackOffice:  ${{ steps.get_urls.outputs.backoffice_url }}"
          echo "   • FrontOffice: ${{ steps.get_urls.outputs.frontoffice_url }}"
          echo "   • API:         ${{ steps.get_urls.outputs.api_url }}"
          echo ""
          echo "=========================================="

      - name: Write deployment URLs to file
        if: always()
        run: |
          cat > deployment-urls.txt << EOF
          ========================================
          DEPLOYMENT URLS
          ========================================

          ALB DNS: ${{ steps.get_urls.outputs.alb_dns }}

          BackOffice URL:  ${{ steps.get_urls.outputs.backoffice_url }}
          FrontOffice URL: ${{ steps.get_urls.outputs.frontoffice_url }}
          API URL:         ${{ steps.get_urls.outputs.api_url }}

          ========================================
          EOF

      - name: Upload deployment URLs artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-urls
          path: deployment-urls.txt

    outputs:
      backoffice_url: ${{ steps.get_urls.outputs.backoffice_url }}
      frontoffice_url: ${{ steps.get_urls.outputs.frontoffice_url }}
      api_url: ${{ steps.get_urls.outputs.api_url }}
      alb_dns: ${{ steps.get_urls.outputs.alb_dns }}
